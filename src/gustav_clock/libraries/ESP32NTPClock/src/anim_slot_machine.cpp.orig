#include "anim_slot_machine.h"
#include <Arduino.h>

SlotMachineAnimation::SlotMachineAnimation(std::string targetText,
                                           unsigned long lockDelay,
                                           unsigned long holdTime,
                                           unsigned long spinDelay,
                                           bool dotsWithPreviousChar)
    : _targetText(targetText),
      _lockDelay(lockDelay),
      _holdTime(holdTime),
      _spinDelay(spinDelay),
      _dotsWithPreviousChar(dotsWithPreviousChar),
      _lastLockTime(0),
      _lastSpinTime(0),
      _lockedCount(0),
      _lockingCompleteTime(0),
      _finalFrameDrawn(false)
{}

// Destructor is empty because std::vector handles its own memory.
SlotMachineAnimation::~SlotMachineAnimation() {}

void SlotMachineAnimation::setup(IDisplayDriver* display) {
    IAnimation::setup(display);

    // There seem to be something weird going on with this parser
    // parseTextAndDots(_targetText, _dotsWithPreviousChar, _parsedText, _dotStates);
    _parsedText = _targetText;
    //  _dotStates.assign(_parsedText.length(), _dotsWithPreviousChar);
    _dotStates.assign(_targetText.length(), 0);
    _isLocked.assign(_display->getDisplaySize(), 0);
    
    // Reset all state variables to ensure the animation can be run multiple times

    _lastLockTime = millis();
    _lastSpinTime = millis();
    _lockedCount = 0;
    _lockingCompleteTime = 0;
    _finalFrameDrawn = false;
    randomSeed(analogRead(0));

    // Draw the initial "spinning" frame immediately in setup to prevent a blank display.
    int displaySize = _display->getDisplaySize();
    for (int i = 0; i < displaySize; ++i) {
        // All digits start as "spinning" (random numbers)
        _display->setChar(i, random(0, 10) + '0', false);
    }
}

bool SlotMachineAnimation::isDone() {
    bool lockingComplete = _lockedCount >= _display->getDisplaySize();
    if (!lockingComplete) {
        return false;
    }
    // Once locking is complete, the animation is done after the holdTime has passed.
    return (millis() - _lockingCompleteTime >= _holdTime);
}

void SlotMachineAnimation::update() {
    // If the final frame has been drawn, do nothing.
    if (_finalFrameDrawn) {
        return;
    }

    int displaySize = _display->getDisplaySize();

    // If the animation's lifecycle is over, draw the final text one last time.
    if (isDone()) {
        // Draw the final, correct text one last time before exiting.
        for (int i = 0; i < displaySize; ++i) {
            if (i < _parsedText.length()) {
            _display->setChar(i, _parsedText[i], _dotStates[i]);
            } else {
                _display->setChar(i, ' ', false); // Pad with blanks if text is short
            }
        }
        // Set this flag to true AFTER drawing. This ensures this block runs once.
        _finalFrameDrawn = true;
        return;
    }

    unsigned long currentTime = millis();
    if (currentTime - _lastSpinTime < _spinDelay) {
        return; // Control the spin speed
    }
    _lastSpinTime = currentTime;

    // --- State Update Logic ---
    bool isLockingPhase = _lockedCount < displaySize;
    if (isLockingPhase && (currentTime - _lastLockTime >= _lockDelay)) {
        _lastLockTime = currentTime;
        if (_lockedCount < _isLocked.size()) {
            _isLocked[_lockedCount] = 1; // Lock the next digit
            _lockedCount++;
        }

        if (_lockedCount == displaySize) {
            _lockingCompleteTime = millis(); // Mark when locking finished
        }
    }

    // --- Atomic Drawing Logic (redraw every digit, every frame) ---
    for (int i = 0; i < displaySize; ++i) {
        if (i < _isLocked.size() && _isLocked[i]) {
            // This digit is locked, show the correct character.
            if (i < _parsedText.length()) {
            _display->setChar(i, _parsedText[i], _dotStates[i]);
            } else {
                _display->setChar(i, ' ', false);
            }
        } else {
            // This digit is still spinning.
            _display->setChar(i, random(0, 10) + '0', false);
        }
    }
}